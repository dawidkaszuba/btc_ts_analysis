---
title: "Analiza cen Bitcoina z wykorzystaniem metod jednowymiarowych szeregów czasowych"
author: "Dawid Kaszuba, Marek Falkowski, Maja Chrzan"
date: "`r format(Sys.Date(), '%Y-%m-%d')`"
output: 
  html_document:
    toc: true
    toc_depth: 3
    theme: cerulean
    highlight: espresso
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```



```{r, include=FALSE}
library(tseries)
library(dplyr)
library(xts)
library(readr)
library(lubridate)
library(TSA)
library(forecast)
```

```{r, include=FALSE}
prices <- read_csv("bitcoin_2010-07-27_2024-04-25.csv")

data <- prices[order(prices$Start), ]
```


```{r}
prices_ts <- ts(data$Close, start = c(2018, 1), end = c(2022,12), frequency = 365)
```

# Cel Analizy


Celem niniejszej analizy jest zbadanie i zrozumienie charakterystyki jednowymiarowego szeregu czasowego cen Bitcoina. Analiza będzie obejmować:

1. **Analizę eksploracyjną danych (EDA):**
    - Wizualizacja danych, aby zrozumieć ogólny trend, sezonowość i potencjalne anomalie w cenach Bitcoina.
    - Statystyczne podsumowanie danych, w tym średnia, mediana, odchylenie standardowe i inne istotne miary.

2. **Dekompozycję szeregu czasowego:**
    - Rozkład szeregu na komponenty trendu, sezonowości i losowe (residualne) za pomocą klasycznej dekompozycji.

3. **Testy stacjonarności:**
    - Przeprowadzenie testów stacjonarności, takich jak test Augmented Dickey-Fuller (ADF), aby określić, czy szereg czasowy jest stacjonarny.

4. **Modelowanie i prognozowanie:**
    - Wybór odpowiedniego modelu do prognozowania przyszłych cen Bitcoina.
    - Ocena dokładności modelu prognozowania za pomocą metryk błędu prognozy (np. RMSE, MAE).

5. **Interpretacja wyników:**
    - Wnioskowanie na podstawie wyników analizy i modelowania, w tym zrozumienie wpływu różnych czynników na zmienność cen Bitcoina.



# Źródło danych, opis i charakterystyka

<div style="text-align: justify;">
  <p>Dane pochodzą ze strony internetowej: https://www.kaggle.com/datasets/priyamchoksi/bitcoin-historical-prices-and-activity-2010-2024. Struktura badanego pliku wygląda następująco:
  </p>
</div>


```{r}
head(data)
```


# Prezentacja graficzna zbioru danych

<div style="text-align: justify;">
Poniżej przedstawiono graficzną analizę danych dotyczących cen Bitcoina za okres od stycznia 2018 roku do grudnia 2022 roku. Na wykresie obserwacjemy ogólny trend wzrostowy, można doszukać się również sezonowych wzorców czy nawet anomalii.
</div>


```{r}
plot(prices_ts,
     main = "Ceny Bitcoina w latach 2018-2022",
     xlab = "",  
     ylab = "Cena [USD]")
```

# Analiza-interpretacja wyników


## Interpretacja funkcji acf oraz pacf


```{r}
Acf(prices_ts, main = "Autokorelacja Cen Bitcoina")
```
```{r}
Pacf(prices_ts)
```
<div>

   tu interpretacja funkcji acf i pacf
   
</div>



```{r}
btc_decomposed <- decompose(prices_ts, "multi")
plot(btc_decomposed)
```
<div style="text-align: justify;">
  <p> 
    Górny panel wykresu pokazuje oryginalny szereg czasowy cen Bitcoina. Widoczny jest ogólny wzrost       cen z kilkoma znaczącymi szczytami,
  </p>
  <p>
    Drugi panel przedstawia komponent trendu, który wskazuje na długoterminowy wzorzec wzrostu cen         Bitcoina. Widzimy, że od początku 2018 roku do końca 2020 roku trend pozostaje stosunkowo płaski z     niewielkimi zmianami. Od 2020 roku trend zaczyna gwałtownie rosnąć, co wskazuje na znaczący wzrost     cen Bitcoina.
  </p>
  <p>
    Trzeci panel pokazuje komponent sezonowy, który reprezentuje powtarzające się wzorce w danych.         Widzimy tutaj regularne wahania w skali rocznej, co sugeruje, że ceny Bitcoina mają pewne sezonowe     wzorce. Te wzorce mogą być związane z określonymi wydarzeniami lub cyklami na rynku kryptowalut.
  </p>
  <p>
    Dolny panel przedstawia komponent losowy, który zawiera te elementy danych, które nie mogą być wyjaśnione przez komponenty trendu ani sezonowości. Mimo to, widać pewne wzorce, które mogą sugerować obecność dodatkowych sezonowych efektów lub innych regularności nie wychwyconych w pełni przez komponent sezonowy. Jest to wskazówka, że model mógł nie w pełni uchwycić całą strukturę sezonową w danych, co może wymagać bardziej zaawansowanych metod modelowania
  </p>
</div>


## Wariancj dla poszczególnych miesięcy 

```{r}
filtered_data <- subset(prices, Start >= as.Date("2018-01-01") & Start <= as.Date("2022-12-31"))

data_monthly <- split(filtered_data$Close, format(filtered_data$Start, "%Y-%m"))
variances <- sapply(data_monthly, var)
plot(1:length(variances), variances, type = "l", xlab = "", ylab = "", main = "Wariancja w Czasie", xaxt = "n")
axis(1, at = 1:length(variances), labels = names(variances))
```
<div style="text-align: justify;">
  <p>
    Wykres pokazuje, że zmienność (wariancja) cen Bitcoina nie jest stała w czasie. Okresy wysokiej zmienności (2020-2021) są przeplatane okresami względnie niskiej zmienności (2018-2019, koniec 2021-2022).
    Szczyty wariancji wskazują na występowanie nagłych, dużych zmian cen. Te szoki mogą być wynikiem zewnętrznych wydarzeń lub fundamentalnych zmian na rynku kryptowalut.
    Powyższy wykres świadczy o tym, że szereg czasowy w swojej pierwotnej wersji jest szeregiem niestacjinarnym.
  </p>
<div>



## Test stacjonarności Dickeya-Fullera


```{r, warning=FALSE}
adf.test(prices_ts)
```
<p>
Testowa statystyka Dickeya-Fullera (-1.9533) jest większa od wartości krytycznej na poziomie istotności 0.05. Oznacza to, że nie ma wystarczających dowodów, aby odrzucić hipotezę zerową (hipoteza o niestacjonarności) na rzecz hipotezy alternatywnej.
Wartość p-wartości (0.5981) jest większa niż ustalony poziom istotności. Jest to dodatkowy dowód na to, że nie mamy podstaw, aby odrzucić hipotezę zerową.
Zgodnie z alternatywną hipotezą, którą testuje test Dickeya-Fullera, wynik sugeruje, że szereg czasowy prices_ts jest niestacjonarny. W skrócie, wynik testu sugeruje, że nie ma wystarczających dowodów, aby odrzucić hipotezę o niestacjonarności szeregu czasowego.
</p>


<p>
  W kolejnym kroku sprawdzono czy można łatwo pozbyć się niestacjonarności dla badanego szeregu czasowego poprzez różnicowanie, które wykonano najpierw z opóźnieniem równym , aby pozbyć się trendu a następnie z opóźnieniem równym 365 aby pozbyć się seznonowości. 
</p>

```{r}
prices_diff <- diff(diff(prices_ts, lag = 1), lag = 365)
```


Sprawdzono czy szereg jest teraz stacjonarny
```{r, warning=FALSE}
adf.test(prices_diff)
```
<p>Ponieważ wartość p (0.01) jest mniejsza niż typowy poziom istotności, możemy odrzucić hipotezę zerową.

Na podstawie testu ADF, możemy stwierdzić, że z dużym prawdopodobieństwem szereg czasowy po różnicowaniu jest stacjonarny.</p>


## Model ARIMA


1. **Analizę eksploracyjną danych (EDA):**

Na podstawie analizy wariancji cen Bitcoina w okresie od stycznia 2018 roku do grudnia 2022 roku oraz testów stacjonarności, model ARIMA (AutoRegressive Integrated Moving Average) jest odpowiednim wyborem do dopasowania i prognozowania szeregów czasowych. Poniżej przedstawiono uzasadnienie tego wyboru:

1. **Niestacjonarność Danych**:
    - Wykres wariancji wskazuje, że szereg czasowy cen Bitcoina w pierwotnej formie jest niestacjonarny. ARIMA jest skuteczny w modelowaniu niestacjonarnych danych poprzez zastosowanie różnicowania, co pozwala przekształcić niestacjonarny szereg czasowy w stacjonarny.

2. **Uwzględnienie Zmienności**:
    - Mimo że występuje zmienność, ARIMA może dobrze dopasować się do danych po transformacjach stabilizujących wariancję (np. różnicowanie logarytmiczne), co pozwala na uchwycenie istotnych wzorców w danych.

3. **Elastyczność Modelu**:
    - Model ARIMA łączy autoregresję (AR), różnicowanie (I) i średnią ruchomą (MA), co daje dużą elastyczność w dopasowywaniu różnych typów szeregów czasowych. Może uchwycić zarówno krótkoterminowe zależności, jak i długoterminowe trendy po odpowiednich transformacjach.

### dopasowanie modelu

```{r}
arima_model <- auto.arima(prices_ts)
summary(arima_model)
```
- ME (Mean Error): Średni błąd prognoz. Tutaj wartość wynosi 0.397, co wskazuje na niewielki przeciętny błąd w prognozach
- RMSE (Root Mean Square Error): Pierwiastek kwadratowy z średniego kwadratu błędu. Wynosi 19.54, co jest używane do oceny jakości prognoz modelu
- MAE (Mean Absolute Error): Średnia bezwzględna różnica między prognozowanymi a rzeczywistymi wartościami. Wynosi 5.73, co wskazuje na przeciętny błąd prognoz
- MPE (Mean Percentage Error): Średni procentowy błąd prognoz. Wynosi 0.38%, co wskazuje na średni procentowy błąd w prognozach
- MAPE (Mean Absolute Percentage Error): Średnia bezwzględna procentowa różnica między prognozowanymi a rzeczywistymi wartościami. Wynosi 4.09%, co jest miarą względnego błędu prognoz
- MASE (Mean Absolute Scaled Error): Skala średniej bezwzględnej różnicy. Wynosi 0.034, co wskazuje na mały błąd prognoz w skali
- ACF1 (Autocorrelation of residuals at lag 1): Autokorelacja reszt z opóźnieniem 1. Wartość 0.0105 sugeruje, że nie ma znaczącej autokorelacji w resztach, co jest pożądane w dobrze dopasowanym modelu

<div style="text-align: justify;">
Model ARIMA(0,1,0) jest prostym modelem różnicującym, który dobrze dopasowuje się do danych po transformacji (różnicowaniu) w celu osiągnięcia stacjonarności. Miary błędu wskazują na umiarkowane błędy prognoz, a niskie wartości autokorelacji reszt sugerują, że model dobrze uchwycił struktury w danych. Wartości AIC i BIC sugerują, że model jest stosunkowo dobrze dopasowany przy umiarkowanej złożoności
</div>

### reszty modelu

```{r}
par(mfrow = c(2, 2))
plot(arima_model$residuals, main = "Reszty modelu ARIMA", ylab = "Reszty")
acf(arima_model$residuals, main = "ACF reszt")
pacf(arima_model$residuals, main = "PACF reszt")
qqnorm(arima_model$residuals)
qqline(arima_model$residuals)
```

<div style="text-align: justify;">
  <p>
    Wykres reszt wskazuje, że model dobrze dopasowuje się do danych na początku, ale występują okresy zwiększonej zmienności, szczególnie po 2020 roku. Obecność wielu wartości ACF i PACF poza granicami istotności sugeruje, że model ARIMA(0,1,0) nie uchwycił wszystkich wzorców w danych. Wskazuje to na potrzebę dalszego dostosowania modelu
  </p>
</div>


# Ocena jakości analizy

<div style="text-align: justify;">
  #todo
</div>

# Porównania wyników dla różnych zbiorów(szeregów) lub metod lub narzędzi

<div style="text-align: justify;">
  #todo
</div>

# Podsumowanie-wniosek

<div style="text-align: justify;">
  #todo
</div>
